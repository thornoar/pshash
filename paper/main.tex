\documentclass[a4paper, 10pt]{article}

\usepackage{tgschola}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{leftindex}
\usepackage{graphicx}
\usepackage[skip=5pt, indent=0pt]{parskip}
\usepackage[top=0.5in, bottom=0.7in, right=0.5in, left=0.5in]{geometry}
\usepackage[]{amsthm}

\theoremstyle{plain}

\newtheorem{theorem}{Theorem}[section]
\newtheorem*{theorem*}{Theorem}

\newtheorem{statement}[theorem]{Statement}
\newtheorem*{statement*}{Statement}

\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{lemma*}{Lemma}

\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{proposition*}{Proposition}

\newtheorem{exercise}[theorem]{Exercise}
\newtheorem*{exercise*}{Exercise}

\theoremstyle{definition}

\newtheorem{definition}[theorem]{Definition}
\newtheorem*{definition*}{Definition}

\newtheorem{example}[theorem]{Example}
\newtheorem*{example*}{Example}

\newtheorem{remark}[theorem]{Remark}
\newtheorem*{remark*}{Remark}

\newtheorem*{notation*}{Notation}

\newtheorem{corollary}{Corollary}[theorem]
\newtheorem*{corollary*}{Corollary}

\renewcommand{\qedsymbol}{$\blacksquare$}

\title{SELECTION-BASED MINIMALISTIC\\ PASSWORD GENERATION}
\author{
  Roman Maksimovich\\
  \href{mailto:rmaksimovich@connect.ust.hk}{rmaksimovich@connect.ust.hk}
}
\date{March 26, 2024}

\newcommand{\N}{\mathbb{N}}
\newcommand{\wo}{\mathbin{!}}
\newcommand{\li}{\leftindex}
\newcommand{\rf}[2]{(#1 \mathbin{\mid} #2)!}
\newcommand{\spr}[1]{\operatorname{spr}(#1)}
\newcommand{\cc}{\mathcal{C}}
\newcommand{\conf}{\mathfrak{L}}
\newcommand{\elv}{\overline{\mathcal{C}}}
\newcommand{\m}{\mathcal{M}}
\newcommand{\mc}{\mathcal{MC}}
\newcommand{\h}{\mathcal{H}}
\newcommand{\s}{\mathcal{S}}

\binoppenalty=10000
\relpenalty=10000

\begin{document}

\maketitle

\textbf{Abstract:}
The traditional model of password management has been failing for the past 25-30 years, with the growth in the number of passwords an average user needs to remember.
To combat this problem, we introduce \texttt{pshash} --- a deterministic ``on-the-fly'' password generation algorithm based on selecting characters from predefined sources. The selection of characters and their order are derived from two secret numbers (the "choice key" and "shuffle key") provided by the user, and the resulting character string can be used as a password. The algorithm resembles a hash function in many ways, however it is not cryptographically secure in the usual sense. Yet it still satisfies the conditions for being a \emph{universal hash function}, and we argue that this is sufficient for secure password generation. Its main benefits are simplicity (it is implemented in under 200 lines of code) and independence (it does not draw on any pre-existing algorithms or cryptographic notions). This comes at the cost of convenience, as the user is required to memorize a relatively large amount of entropy to achieve good security. However, we argue that practice can mitigate this drawback, and the benefits of security and minimalism are worth it.

\textbf{Keywords:}
Passwords, Authentication, Combinatorics, Functional Programming

\section{Introduction} \label{intro}

In our time, the average computer user has more than 40 different accounts which require usernames and passwords \cite{mirkovic}. Overall, we can distinguish between three methods of managing them, in increasing levels of security and decreasing levels of convenience:

\begin{itemize}
  \item \textbf{Memorizing passwords directly.} Much like the one-time pad encryption scheme \cite{serious}, this method theoretically provides the best possible security, assuming that all passwords are strong and have no connection to each other. Unfortunately, with a large number of passwords this assumption fails entirely. Statistical studies report that most people reuse their passwords between both important sites (e.g. banking, work-related) and less critical sites (e.g. forums, social media), and overall choose weak passwords for the sake of simplicity \cite{large}, \cite{mirkovic}, \cite{again}. Naturally, this leads to the idea of using computer-assisted password management.

  \item \textbf{Using a password manager.} These are software programs that can store a user's passwords in an encrypted database, allowing the user to decrypt it using a \emph{master password}. Examples include 1Password \cite{1password}, Google Chrome \cite{google}, and Mozilla Firefox \cite{firefox}. A great advantage of password managers is the ability to create random and provably strong passwords on behalf of the user. However, password managers have been criticised for insecure database storage formats \cite{gasti} and auto-fill policies \cite{attacks}, which both leave doors for various attacks. It appears that the sources of most vulnerabilities are 1) the fact that passwords are stored on disk, albeit in an encrypted form; and 2) the tight integration of password managers with browsers, provided for the sake of convenience and some security features such as defence against phishing and spoofing \cite{ross}. Additionally, many password managers are closed-source, which hinders one's trust that the password manager will not abuse the passwords it stores.

  \item \textbf{Using a deterministic ``on-the-fly'' password generator.} These are programs that allow the user to derive a password from their identity and a secret master password, using a stateless (usually hash-based) function. An example is PwdHash \cite{ross}. This approach eliminates the problem of storage, since nothing is ever stored on disk. However, being based on well-known hash functions opens such schemes to dictionary attacks and brute-force attacks, although mitigated in \cite{conv}. Still, deterministic password generators are still more complicated than they could be, and they often require users to provide their identity, which hinders anonymity.
\end{itemize}

In this paper, we specify a new ``on-the-fly'' password generation algorithm \texttt{pshash} that differs from its alternatives in two important ways:

\begin{itemize}
  \item \texttt{pshash} is extremely minimalistic (written in under 200 lines of code) and standalone, which makes it very portable and easy to implement on any platform and in any programming language that supports arbitrary-precision arithmetic (see Section \ref{impl} for a discussion of \texttt{pshash}'s implementation). The program is detached from any external service or browser, making it invulnerable to supply chain attacks.

  \item Our algorithm uses a custom universal hash function instead of the ``industry standards'' of cryptographic hashing such as SHA-256 or Salsa20. This means that our algorithm is immune to attacks targeting these hash functions, such as dictionary attacks.
\end{itemize}

The above benefits come at the cost of convenience, which means that \texttt{pshash} is probably ill-suited for mass adoption. However, it fits perfectly for technically educated users who do not mind memorizing a couple of 20+ digit numbers for the sake of security.

\section{The Algorithm Specification} \label{spec}

In this section, we give a full description of \texttt{pshash}. The algorithm is a pure stateless function that takes as input three values:

\begin{itemize}
  \item The domain name (or any other distinct identifier) of the website for which a password is required, called the \emph{public key} and denoted $p$;
  \item A secret non-negative integer $k_1$ which lies in a vast range (on the order of $2^{142}$, typically), called the \emph{choice private key};
  \item Another secret non-negative integer $k_2$, which lies in a smaller range of numbers (on the order of $2^{83}$, typically), called the \emph{shuffle private key}.
\end{itemize}

The function returns a string of characters which we call a ``pseudo-hash'' since it is not a full cryptographic hash but has some of its properties. \texttt{pshash} does not derive the characters from the keys directly, but instead uses them to select characters from predefined \emph{sources}, which makes it much easier to make sure the pseudo-hash complies with a website's password requirements. The algorithm also supports different password templates, called \emph{source configurations.} We will now consider the algorithm in detail.

\subsection{Preliminary Terminology and Notation}

Symbols $A, B, C$ will denote arbitrary sets (unless specified otherwise). $\N_0$ is the set of all non-negative integers.

By $E$ we will commonly denote a finite enumerated set of distinct elements, called a \emph{source.} When multiple sources $E_0, E_1, ..., E_{N-1}$ are considered, we take none of them to share any elements between each other. In other words, their pairwise intersections will be assumed to be empty.

The symbol ``$\#$'' will be used to denote the number of ways to make a combinatorial selection. For example, $\#^m (E)$ is the number of ways to choose $m$ elements from a source $E$ with significant order.

The expression $[A]$ will denote the set of all ordered lists composed from elements of the set $A$. We assume that all elements in a list are distinct. Every list can therefore be considered a source. The subset $[A]_m \subset [A]$ will include only the lists of length $m$. Extending this notation, we will define $[A_0, A_1, ..., A_{N-1}]$ as the set of lists $\alpha = [a_0, a_1, ..., a_{N-1}]$ of length $N$, where the first element is from $A_0$, the second from $A_1$, and so on, until the last one from $A_{N-1}$. Finally, if $\alpha \in [A]$ and $\beta \in [B]$, the list $\alpha \uplus \beta \in [A \cup B]$ will denote the concatenation of lists $\alpha$ and $\beta$.

Let $\alpha$ be a list. By $|\alpha|$ we will denote its length, while $\alpha : i$ will represent its $i$-th element, with the enumeration starting from $i = 0$. By contrast, the expression $\alpha \wo i$ will denote the list $\alpha$ without its $i$-th element. All sources are associated with the ordered list of all their elements, and so expressions like $E : i$ and $|E|$ also have meaning for a source $E$.

Let $k \in \N_0, n \in \N$. The numbers $\li^n k, \li_n k \in \N_0$ are defined to be such that $0 \leq \li^n k < n$ and $\li_n k \cdot n + \li^n k = k$.  The number $\li^n k$ is the remainder after division by $n$, and $\li_n k$ is the result of division.

For a number $n \in \N$, the expression $(n)$ will denote the semi-open integer interval from $0$ to $n$, $(n) = \{0, ..., n-1\}$.

Let $n,m \in \N,\ m \leq n$. The quantity $n!/(n-m)!$ will be called a \emph{relative factorial} and denoted by $\rf{n}{m}$.

Consider a function $f$ of many arguments $a_0, a_2, ..., a_{n-1}$. Then with the expression $f(a_0, ..., a_{i-1}, -, a_{i+1}, ..., a_{n-1})$ we will denote the function of one argument $a_i$ where all others are held constant.

\subsection{Enumerating List Selections}

The purpose of the public key $p$ is solely to allow the user to generate different passwords with the same set of private keys. Therefore, it need not be an integral part of the core \emph{pshash} algorithm. In this and the following subsections we will build the function $\h(\conf, k_1, k_2)$ which accepts a source configuration and two private keys to produce a pseudo-hash, and we will explain the origin of the decision to use two private keys instead of one.\\

\begin{definition}[First-order choice function]
  \label{c1ek}
  Let $E$ be a source, $k \in \N_0$. The \emph{choice function of order 1} is defined for $E$ and $k$ as the following one-element list:
  \[
    \cc^1 (E,k) = \left[ E : \li^{|E|}k \right].
  \]
\end{definition}

It corresponds to picking one element from the source according to the key. For a fixed source $E$, the choice function is periodic with a period of $|E|$ and is injective  on the interval $(|E|)$ with respect to $k$. Injectivity is a very important property for a pseudo-hash function, since it determines the number of keys that produce different outputs. When describing injectivity on intervals, the following definition proves useful:\\

\begin{definition}
  Let $A$ be a finite set and let $f \colon \N_0 \to A$ be a function. The \emph{spread} of $f$ is defined to be the largest number $n$ such that, for all distinct $k_1, k_2 \in \N_0$, the following implication holds:
  \[
    f(k_1) = f(k_2) \implies |k_1 - k_2| \geq n.
  \]
  This number exists due the $A$ being finite. We will denote the spread of $f$ by $\spr{f}$.\\
\end{definition}

Trivially, if $\spr{f} \geq n$, then $f$ is injective on $(n)$, but the converse is not always true. Therefore, a lower bound on the spread of a function serves as a guarantee of its injectivity on a certain interval. Furthermore, if $\spr{f} \geq n$ and $f$ is bijective on $(n)$, then $f$ is periodic with period $n$ and therefore has a spread of exactly $n$. We leave these facts as a simple exercise for the reader.\\

\begin{proposition}
  \label{map}
  Let $f \colon \N_0 \to A,\ g \colon \N_0 \to B$ be two functions such that $\spr{f} \geq n$ and $\spr{g} \geq m$. Define the function $h \colon \N_0 \to [A,B]$ as follows:
  \[
    h(k) = [f(\li^n k),\ g(\li_n k + T(\li^n k))],
  \]
  where $T \colon \N_0 \to \N_0$ is a fixed function, referred to as the \textbf{argument shift function.} It is then stated that $\spr{h} \geq n m$.
\end{proposition}
\begin{proof}
  Assume that $k_1 \ne k_2$ and $h(k_1) = h(k_2)$. Since $h$ returns an ordered list, the equality of lists is equivalent to the equality of all their respective entries:
  \begin{align*}
    f(\li^n k_1) &= f(\li^n k_2),\\
    g(\li_n k_1 + T(\li^n k_1)) &= g(\li_n k_2 + T(\li^n k_2)).
  \end{align*}
  Since $f$ is injective on $(n)$, we see that $\li^n k_1 = \li^n k_2$. Consequently, it follows from $k_1 \ne k_2$ that $\li_n k_1 \ne \li_n k_2$ and so $\li_n k_2 + T(\li^n k_1) \ne \li_n k_2 + T(\li^n k_2)$. We then utilize the definition of $\spr{g}$:
  \begin{align*}
    |\li_n k_1 + T(\li^n k_1) - \li_n k_2 - T(\li^n k_2)| &\ge m,\\
    |\li_n k_1 - \li_n k_2| &\ge m,\\
    \left| \frac{k_1 - \li^n k_1}{n} - \frac{k_2 - \li^n k_2}{n} \right| &\ge m,\\
    \left| \frac{k_1 - k_1}{n} \right| &\ge m,\\
    | k_1 - k_1 | &\ge n m,\\
  \end{align*}
  q.e.d.
\end{proof}

With this proposition at hand, we have a natural way of extending the definition of the choice function:\\

\begin{definition}
  Let $E$ be a source with cardinality $|E| = n$, and let $k \in \N_0,\ 2 \le m \le n$. The \emph{choice function of order $m$} is defined for $E$ and $k$ recursively as follows:
  \[
    \cc^m (E,k) = [E : \li^n k] \uplus \cc^{m-1}(E', k'),
  \]
  where $E' = E \wo \li^n k$ and $k' = \li_n k + T(\li^n k)$, while $T \colon \N_0 \to \N_0$ is a fixed argument shift function.\\
\end{definition}

\begin{proposition}
  Let $E$ be a source with cardinality $n$. Then the choice function $\cc^m(E,-)$ of order $m \le n$, as a function of $k$, has a spread of at least $\rf{n}{m}$.
\end{proposition}
\begin{proof}
  We will conduct a proof by induction over $m$. In the base case, $m = 1$, we notice that $\rf{n}{1} = n$, and the statement trivially follows from the definition of $\cc^1(E,k)$.

  Let us assume that the statement is proven for all choice functions of order $m-1$. Under closer inspection it is clear that the definition of $\cc^m(E, k)$ follows the scheme given in Proposition \ref{map}, with $\cc^1(E,-)$ standing for $f$ and $\cc^m(E', -)$ standing for $g$. The application of the proposition is not entirely trivial, and we encourage the reader to consider the caveats. Thus, we can utilize the statement of the proposition as follows:
  \begin{align*}
    \spr{\cc^m(E,-)} \ge \spr{\cc^1(E, -)} \cdot \spr{\cc^{m-1}(E', -)} \ge n \cdot \rf{n-1}{m-1} = \rf{n}{m},
  \end{align*}
  q.e.d.
\end{proof}

The above result is especially valuable considering the fact that there are exactly $\rf{n}{m}$ ways to select an ordered sub-list of length $m$ from a list of length $n$, meaning that $\cc^m(E,-)$ is not only injective, but also surjective on the interval $(\rf{n}{m})$. This makes it a bijection
\[
  \cc^m(E,-) \colon (\rf{n}{m}) \to [E]_m,
\]
and therefore a periodic function with a spread of exactly $\rf{n}{m} =: \#^m (E)$.

These properties make the choice function a fine candidate for a pseudo-hash map. Suppose that the source $E$ is composed from lower-case and upper-case characters, as well as special symbols and digits:
\[
  E = 
  \text{\texttt{"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789!@\#\$\%"}}
\]

The choice function gives us a way to enumerate all possible ways to select a sub-list from $E$. What is more, these selections can be made more ``random'' and unpredictable by means of complicating the argument shift function $T$. A reasonable practice is to set $T(\li^n k)$ to the ASCII value of the character $E : \li^n k$. This way, each chosen character will influence the choice of the next, creating what is called a ``chaotic system'', where its behavior is fully determined, but even small changes to inputs eventually produce large changes in the output. Here is a little input-output table for the choice function of order 10 with the specified source and shift function:

\begin{center}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{c|c}
  input & output\\
  \hline
  123 & \texttt{41BeGs9\$Dd}\\
  \hline
  124 & \texttt{52NgJfZIk7}\\
  \hline
  125 & \texttt{63MfHs9\$Da}\\
  \hline
  126 & \texttt{740VbDo6@u}\\
  \hline
  127 & \texttt{851Br469\$S}\\
\end{tabular}
\end{center}

There is, however, a serious problem. This selection method does not guarantee that the chosen 10 symbols will contain lower-case and upper-case characters, as well as digits and special symbols, all at the same time. Since the choice function is bijective, there is a key that produces the combination \texttt{"djaktpsnei"}, which will not be accepted as a password in many places, because it contains only one category of symbols.

\subsection{Elevating the Choice Function}

\begin{definition}
  Let $\conf$ be list of pairs $(E_i, m_i)$, where $E_i$ are sources, $|E_i| = n_i,\ m_i \le n_i$, for $i \in (N)$. The \emph{elevated choice function} $\elv(\conf, -)$ corresponding to these data is defined for a key $k \in \N_0$ by means of the following recursion:
  \[
    \elv(\conf, k) = \left[ \cc^{m_0}(E_0, \li^{n_0} k) \right] \uplus \elv(\conf \wo 0, \li_{n_0} k + T(\li^{n_0} k)),
  \]
  where $T$ is an argument shift function. The base of the recursion is given when $\conf$ is empty, in which case $\elv([], k) = []$. Otherwise, for every key $k$, its image under $\elv(\conf, -)$ is an element of
  \[
    \operatorname{cod} \left( \elv(\conf, -) \right) = \left[ [E_0]_{m_0}, [E_1]_{m_1}, ..., [E_N]_{m_N} \right].
  \]
  In this context, the list $\conf$ will be called a \emph{source configuration.}
\end{definition}

In other words, the elevated choice function is a ``mapping'' of the choice function over a list of sources, it selects a sub-list from every source and then composes the results in a list, which we call a \emph{multiselection.} A trivial application of Proposition \ref{map} shows that the spread of $\elv(\conf, -)$ is at least
\begin{align}
  \label{elspr}
  \prod_{i = 0}^{N-1} \spr{\cc^{m_i}(E_i, -)} = \prod_{i = 0}^{N-1} \rf{n_i}{m_i},
\end{align}
where $E_i$, $n_i$, and $m_i$ compose the configuration $\conf$. In fact, due to the rule of product in combinatorics, we see that the expression in (\ref{elspr}) directly corresponds to the number of possible multiselections from $\conf$, or $\#^{\elv} (\conf)$ for short. Therefore, $\elv(\conf, -)$ is bijective on the interval $\left( \#^{\elv} (\conf) \right)$ and periodic with period $\#^{\elv} (\conf)$.

This solves the problem with lacking symbol categories --- now we can separate upper-case letters, lower-case letters, numbers, etc., into different sources and apply the elevated choice function, specifying the number of symbols from each source. However, there are two issues arising:

\begin{itemize}
  \item The result of the elevated choice function will be something like \texttt{"amwYXT28@!"}, which is not a bad password, but it would be nice to be able to shuffle the individual selections between each other instead of lining them up one after another.
  \item Despite the fact that the argument shift function makes the password selection chaotic, the function is a bijection, which means that it can be reversed. With sufficient knowledge of the algorithm, an attacker can write an inverse algorithm that retrieves the private key from the resulting password. This is a deal breaker for our function, because it defeats the purpose --- you may as well have one password for everything. The way to solve this problem is to make the choice function artificially non-injective, or non-collision-free, in a controlled way. In such case, many different keys will produce the same password, and it will be impossible to know which one of them is the correct one. This violates the common non-collision property of hash functions, but it is necessary given the nature of the function we are building.
\end{itemize}

We will solve one problem at a time.

\subsection{The Merge Function}

\begin{proposition}
  \label{comp}
  Let $f \colon A \times \N_0 \to B$ and $g \colon B \times \N_0 \to C$ be functions such that $\spr{f} \ge n$ and $\spr{g} \ge m$, where the spread is taken with respect to the second argument. Assume also that $g$ is \textbf{absolutely injective} with respect to the first argument, that is,
  \[
    \forall (b_1,k_1), (b_2,k_2) \in B \times \N_0,\ \ g(b_1, k_1) = g(b_2, k_2) \implies b_1 = b_2.
  \]
  Define the function $h \colon A \times \N_0 \to C$ by
  \[
    h(a, k) = g(f(a, \li^n k), \li_n k + T(\li^n k)),
  \]
  where $T$ is an argument shift function. It is then stated that $\spr{h} \ge n m$ with respect to $k$.
\end{proposition}
\begin{proof}
  Take an element $a \in A$ and let $k_1, k_2$ be distinct numbers such that $h(a, k_1) = h(a, k_2)$. It means that
  \[
    g(f(a, \li^n k_1), \li_n k_1 + T(\li^n k_1)) = g(f(a, \li^n k_2), \li_n k_2 + T(\li^n k_2)).
  \]
  Since $g$ is absolutely injective, we see that $f(a, \li^n k_1) = f(a, \li^n k_2)$, which means that $\li^n k_1 = \li^n k_2$, since $f$ is injective on the interval $(n)$. Now, since the first argument of $g$ in the above equation is the same, we can use the definition of spread for the function $g$:
  \begin{align*}
    |\li_n k_1 + T(\li^n k_1) - \li_n k_2 - T(\li^n k_2)| &\ge m,\\
    |\li_n k_1 - \li_n k_2| &\ge m,\\
    \left| \frac{k_1 - \li^n k_1}{n} - \frac{k_2 - \li^n k_2}{n} \right| &\ge m,\\
    \left| \frac{k_1 - k_2}{n} \right| &\ge m,\\
    \left| k_1 - k_2 \right| &\ge n m,\\
  \end{align*}
  q.e.d.
\end{proof}

\begin{definition}
  Let $E_1, E_2$ be two sources, $m_1, m_2$ be numbers such that $m_i \le |E_i|$ for $i = 1,2$. Define the \emph{merge function of order 2},
  \[
    \m^2 \colon [E_1]_{m_1} \times [E_2]_{m_2} \times \N_0 \to [E_1 \cup E_2]_{m_1 + m_2},
  \]
  with the following recursive procedure: for $\alpha \in [E_1]_{m_1},\ \beta \in [E_2]_{m_2},\ k \in \N_0$, consider two cases:
  \begin{enumerate}
    \item Either $\alpha$ or $\beta$ is empty, that is, $m_1 = 0$ or $m_2 = 0$. Then we set $\m^2 (\alpha, \beta, k)$ to $\alpha \uplus \beta$.
    \item Neither $\alpha$ nor $\beta$ is empty. Then we will assume that the merge function is already refined for $(\alpha \wo 0, \beta, -)$ and $(\alpha, \beta \wo 0, -)$. Let $s_1$ be the spread of the function $\m^2(\alpha \wo 0, \beta, -)$ and $s_2$ be the spread of $\m^2 (\alpha, \beta \wo 0, -)$. Finally, denote the remainder $\li^{(s_1+s_2)}k$ by $k'$. The merge of $\alpha$ and $\beta$ with key $k$ and an argument shift function $T$ is defined as
      \[
        \m^2(\alpha, \beta, k) = \begin{cases}
          [\alpha : 0] \uplus \m^2(\alpha \wo 0, \beta, k' + T(k')),\ \mathrm{if}\ k' < s_1,\\
          [\beta : 0] \uplus \m^2(\alpha, \beta \wo 0, k' + T(k')),\ \mathrm{otherwise}.\\
        \end{cases}
      \]
  \end{enumerate}
  The merge function takes two lists and combines them together in one, in such a way that the order of elements in each of the two lists is not disturbed. For example, the merge of $[1,2,3]$ and $[a,b,c]$ with a certain key could be $[1,a,b,2,c,3]$. We will now derive some properties of $\m^2$. If $s_1$ and $s_2$ are as defined above, we immediately see that $\m^2(\alpha, \beta, -)$ is periodic with period $s_1 + s_2$, since it depends only on $k' = \li^{(s_1 + s_2)}k$. Moreover, it is clear from the definition that $\m^2 (\alpha, \beta, -)$ is injective on the interval $(s_1 + s_2)$, which means that its spread equals exactly $s_1 + s_2$:
  \begin{align}
    \label{recspr}
    \spr{\m^2(\alpha, \beta, -)} = \spr{\m^2 (\alpha \wo 0, \beta, -)} + \spr{\m^2(\alpha, \beta \wo 0, -)}.
  \end{align}
\end{definition}

\begin{proposition}
  \label{sprm2}
  Let $\alpha$ and $\beta$ be lists from $[E_1]_{m_1}$ and $[E_2]_{m_2}$ respectively. Then the spread of the corresponding merge function $\m^2(\alpha, \beta, -)$ with respect to the key $k$, is equal to $(m_1 + m_2)!/(m_1 ! \cdot m_2 !)$.
\end{proposition}
\begin{proof}
  We will conduct a proof by induction over the sum $m_1 + m_2$. The base case is provided by the situation when either $m_1$ or $m_2$ is zero. Now, assume that $m_1, m_2 \ne 0$ and for all similar pairs with sum $m_1 + m_2 - 1$ the statement is proven. Recall (\ref{recspr}), which we can now transform due to the induction hypothesis:
  \begin{align*}
    \spr{\m^2(\alpha, \beta, -)} = \frac{((m_1 - 1) + m_2)!}{(m-1)! \cdot m_2 !} + \frac{(m_1 + (m_2 - 1))!}{m_1 ! \cdot (m_2 - 1)!} =\\
    = \frac{m_1 \cdot (m_1 + m_2 - 1)! + m_2 \cdot (m_1 + m_2 - 1)!}{m_1 ! \cdot m_2 !} = \frac{(m_1 + m_2)!}{m_1! \cdot m_2!},
  \end{align*}
  q.e.d.
\end{proof}

Using basic combinatorics, we can see that the number $(m_1 + m_2)!/(m_1 ! \cdot m_2 !)$ corresponds to the number of all possible ways to merge the lists $\alpha$ and $\beta$, which we will denote by $\#^\m (\alpha, \beta)$. It means that the function $\m^2 (\alpha, \beta, -)$ is in fact surjective, and therefore bijective, on the interval from zero to its spread. Now we will expand its definition to an arbitrary number of lists.\\

\begin{definition}
  Let $\overline{\alpha} = [\alpha_0, \alpha_1, ..., \alpha_{N-1}]$ be a list of lists, where $N \ge 2$ and $\alpha_i \in [E_i]_{m_i}$. Define the \emph{merge function of order $N$} recursively as follows:
  \begin{align}
    \label{mNdef}
    \m^N (\overline{\alpha}, k) = \begin{cases}
      \m^2 (\alpha_0, \alpha_1, k),\ \ N = 2,\\
      \m^2 (\alpha_0, \m^{N-1} (\overline{\alpha} \wo 0, \li^s k), \li_s k + T(\li^s k)),\ \ N > 2,
    \end{cases}
  \end{align}
  where $s$ is the spread of the function $\m^{N-1} (\overline{\alpha} \wo 0, -)$, and $T$ is an argument shift function.\\
\end{definition}

\begin{proposition}
  Let $\overline{\alpha} = [\alpha_0, \alpha_1, ..., \alpha_N]$ be a list of lists with $\alpha_i \in [E_i]_{m_i}$. Then we have
  \begin{align}
    \label{sprmN}
    \spr{\m^N (\overline{\alpha}, -)} = \frac{\left( \sum_{i = 0}^{N-1} m_i \right)}{\prod_{i = 0}^{N-1} m_i !}.
  \end{align}
\end{proposition}
\begin{proof}
  We conduct a proof by induction over $N$. If $N = 2$, the result follows from Proposition \ref{sprm2}. Now, assume that the result holds for all merge functions of order $N-1$. Note that (\ref{mNdef}) follows the definition scheme assumed in Proposition \ref{comp}, and by applying its result, we see that (\ref{sprmN}) holds for $\m^N (\overline{\alpha}, -)$.
\end{proof}

\subsection{Merging the Multiselection} \label{mergemult}

\begin{definition}
  Let $\conf$ be a source configuration of pairs $(E_i, m_i)$ for $i \in (N)$, and let $k$ be a non-negative integer. We define the \emph{merged choice function} corresponding to $\conf$, as follows:
  \[
    \mc(\conf, k) = \m^N \left( \elv(\conf, \li^n k),\ \li_n k + T(\li^n k) \right),
  \]
  where $n$ is the spread of the elevated choice function $\elv(\conf, -)$, while $T$ is a fixed argument shift function.\\
\end{definition}

In other words, the merged choice function selects $N$ lists from the configuration via $\elv$, and then merges them together using $\m^N$. We have therefore solved our first problem --- the password resulting from this new pseudo-hash function will have different categories of characters mixed together. What is more important, there is no information lost in the process, which is illustrated by the following proposition:\\

\begin{proposition}
  Let $\conf$ be a source configuration of length $N$. The following lower bound takes place for the spread of the merged choice function:
  \begin{align}
    \label{sprmc}
    \spr{\mc(\conf, -)} \ge \spr{\elv(\conf, -)} \cdot \spr{\m^N (\overline{\alpha}, -)} = \prod_{i = 0}^{N-1} \rf{n_i}{m_i} \cdot \frac{\left( \sum_{i = 0}^{N-1} m_i \right)!}{\prod_{i = 0}^{N-1} m_i !},
  \end{align}
  where $\overline{\alpha}$ is the multiselection arising from the application of $\elv$, while $n_i$ are the lengths of the sources $E_i$ in the configuration $\conf$.
\end{proposition}
\begin{proof}
  Since the merge function $\m^N$ preserves the order of the lists it merges, we can see that it is absolutely injective with respect to its first argument, $\overline{\alpha}$. Indeed, no matter how the multiselection $\overline{\alpha}$ is merged, all elements of, say, $E_0$, can be read from the resulting merged list in the order that they were originally. In other words, the list $\alpha_0 \in \overline{\alpha}$ can be reconstructed from the output of $\m^N (\overline{\alpha}, k)$ for all $k$. And so can $\alpha_1$, $\alpha_2$, etc. Here we are actively using the fact that all elements across all sources $E_0, E_1, ..., E_{N-1}$ are distinct. Now that the absolute injectivity of $M^N$ has been established, our statement immediately follows from an application of Proposition \ref{comp}.
\end{proof}

It can once again be shown using combinatorics, that the final expression in (\ref{sprmc}) is, in fact, the total number of ways to choose a multiselection from $\conf$ and merge it (the reader should not hesitate to check this). Therefore, we conclude that the function $\m(\conf, -)$ is bijective on the interval from zero to its spread, and therefore periodic with the period of its spread.

\subsection{Subverting Invertibility}

We still have one problem left: our current pseudo-hash function is bijective, and it can be inverted relatively easily to retrieve the private key from the source configuration and the final pseudo-hash. To prevent this, we will have to make our function a bit less injective --- artificially add inputs that produce the same output, in order to make the function harder to invert.\\

\begin{definition}
  Let $\conf$ be a source configuration consisting of pairs $(E_i, m_i)$ for $i \in (N)$, with $n_i = |E_i|$. Let $k_1, k_2 \in \N_0$ be two numbers referred to as \emph{choice key} and \emph{shuffle key}. Define the \emph{pseudo-hash} corresponding to these inputs as follows:
  \[
    \h(\conf, k_1, k_2) = \cc^{\sum m_i} (\mc(\conf, k_1), k_2).
  \]
  This definition can be re-written in a more concise way by defining the \emph{shuffle function} $\s(\alpha, k)$ for a list $\alpha$ as $\cc^{|\alpha|}(\alpha, k)$, and letting the source configuration be the varying argument:
  \[
    \h(-, k_1, k_2) = \s(-, k_2) \circ \mc(-, k_1).
  \]
  This pseudo-hash function makes a multiselection from every source in the configuration, then merges them together with the merge function, and finally reshuffles the resulting list.\\
\end{definition}

We call $\h(\conf, -, -)$ a ``pseudo-hash'' here because it does not adhere to the formal definition of a cryptographic hash. Still, such naming is somewhat justified, given that $\h$ is a mapping that is impossible to invert, with a uniform distribution of outputs (given a uniform distribution of keys). The reason $\h$ is not a proper hash function is the fact that for each ``hash'' it produces, one may easily construct key pairs that result in this hash. However, there is no way to pinpoint the pair that was actually used. We will now discuss the properties of $\h(\conf, -, -)$ for a given source configuration $\conf$:

\begin{itemize}
  \item \textbf{Injectivity.} For any $k_2 \in \N_0$, the function $\h(\conf, -, k_2)$ is injective on the interval from zero up to
    \[
      \#^\mc (\conf) := \spr{\mc(\conf, -)} = \prod_{i = 0}^{N-1} \rf{n_i}{m_i} \cdot \frac{\left( \sum_{i = 0}^{N-1} m_i \right)!}{\prod_{i = 0}^{N-1} m_i !}.
    \]
    This is because $\mc(\conf, -)$ is injective on this interval, and $\s(-, k_2)$ is a bijection. With respect to the shuffle key $k_2$, the function $\h(\conf, k_1, -)$ is injective on the spread of $\s$, which is
    \[
      \#^\s (\conf) := \spr{\s(\alpha, -)} = \#^{|\alpha|} (\alpha) = \rf{|\alpha|}{|\alpha|} = |\alpha|! = \left( \sum_{i = 0}^{N-1} m_i \right)!,
    \]
    where $\alpha = \mc(\conf, k_1)$. Therefore, the number of relevant key pairs for the pseudo-hash function, denoted by $\#^{(k_1, k_2)}(\conf)$, is
    \begin{align}
      \label{k1k2}
      \#^{(k_1,k_2)}(\conf) = \#^\s (\conf) \cdot \#^\mc (\conf) = \prod_{i=0}^{N-1} \rf{n_i}{m_i} \cdot \left( \left( \sum_{i=0}^{N-1} m_i \right)! \right)^2 \cdot \left( \prod_{i = 0}^{N-1} m_i ! \right)^{-1}.
    \end{align}
  \item \textbf{Collisions.}
    However, the number in (\ref{k1k2}) does not equal the number of all possible values of $\h$. When applying $\s$ after $\mc$, we are changing the order of elements in each source twice. That is, the information about the order of these elements, stored in the output of $\elv$, is lost after this output is reshuffled with $\s$. The number $\#^\h (\conf)$ of all possible outputs of $\h(\conf, -, -)$ is the number of ways of choosing $m_i$ elements from $E_i$ (unordered), multiplied by the number of ways to reorder them as one list. We therefore recognize that
    \[
      \#^\h (\conf) = \prod_{i=0}^{N-1} {n_i \choose{m_i}} \cdot \left( \sum_{i = 0}^{N-1} m_i \right)!.
    \]
    Now, due to the fact that all resulting hashes are equally likely for $k_1, k_2$ within their respective injectivity intervals, we can calculate the number of different $(k_1, k_2)$ pairs that produce the same hash in a fixed configuration, $\#^\cap (\conf)$:
    \[
      \#^\cap (\conf) = \frac{\#^{(k_1,k_2)}(\conf)}{\#^\h (\conf)} =
      \frac{\prod_{i=0}^{N-1} \rf{n_i}{m_i} \cdot \left( \left( \sum_{i=0}^{N-1} m_i \right)! \right)^2 \cdot \left( \prod_{i = 0}^{N-1} m_i ! \right)^{-1}}{\prod_{i=0}^{N-1} {n_i \choose{m_i}} \cdot \left( \sum_{i = 0}^{N-1} m_i \right)!} = \left( \sum_{i = 0}^{N-1} m_i \right)!.
    \]
\end{itemize}

With respect to each of the two keys, $\h$ is injective, but in combination they clash together and, in a sense, encrypt each other, erasing the trace to the original pair of keys. It does mean that the pseudo-hash function now requires two private keys instead of one, but it is a minor disadvantage in our opinion.

\subsection{The Public Key}

At this stage, the only way is to create a new choice-shuffle key pair for every new occasion. This is where the public key comes into play. The public key, denoted $p$, is an integer defined by the particular context in which the algorithm is invoked. We will assume it to be the name of the website/organization for which we require a password, like \texttt{"google"}, for example, converted into a number by treating the characters in the string as digits in base-128. This number acts on the choice private key by shifting it modulo $\#^\mc (\conf)$:
\[
  k'_1 = \li^{\#^\mc (\conf)}(k_1 + p)
\]
and then this new choice key is plugged into the pseudo-hash function along with the shuffle key. Due to the injectivity of $\h$ with respect to $k_1$, we see that different public keys produce different output hashes, as long as they remain in the interval $(\#^\mc (\conf))$. The influence of $p$ on $k_1$ is simple and predictable, but it doesn't have to be complex, since the public key is not directly responsible for any encryption. Instead it is supposed to be plain and easily remembered.

\section{Security Properties} \label{security}

In this section, we will use a specific source configuration $\conf$, particularly the following:

\begin{center}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{c|l|c|c}
    $i$ & $E_i$ & $n_i$ & $m_i$\\
    \hline
    $0$ & \texttt{"ckapzfitqdxnwehrolmbyvsujg"} & $26$ & $8$\\
    \hline
    $1$ & \texttt{"RQLIANBKJYVWPTEMCZSFDOGUHX"} & $26$ & $8$\\
    \hline
    $2$ & \texttt{"=!*@?\$\%\#\&-+\^{}"} & $12$ & $5$\\
    \hline
    $3$ & \texttt{"1952074386"} & $10$ & $4$\\
  \end{tabular}
\end{center}

Therefore, every password produced with this configuration will contain a total of $25$ symbols, $8$, $8$, $5$ and $4$ from their respective categories.

We will also assume that an adversary can perform $10^{10}$ password checks per second, i.e. 0.1 nanosecond to perform one operation such as computing a pseudo-hash or computing a key pair that produces a given pseudo-hash value. This measure is in fact extremely conservative. For example, running \verb|openssl speed -evp sha256| to benchmark the speed of SHA256 on an 22-core Intel Ultra 9 185H CPU has yielded a speed of $10,000,000$ hashes per second, or 100 nanoseconds per hash. We assume here that \texttt{pshash} is $1,000$ times faster, whereas in fact it must be orders of magnitude slower, due to the fact that it must perform many arithmetic operations on arbitrary-precision integers. This conservative speed estimate serves as a guarantee of security for a long period of time, even when processors become a million times faster than they are today.

We will now consider various attacks on the pseudo-hashes produced by \texttt{pshash}.

\subsection{Brute-force Attacks on Pseudo-hashes}

First of all, an adversary might try to brute-force a given password by iterating over all $25$-letter strings made of $8$ lower-case letters, $8$ upper-case letters, $5$ special characters, and $4$ digits. They would have to check $\#^\h (\conf)$ combinations, which in our case is
\[
  \#^\h (\conf) = 
  6,296,585,738,425,733,189,152,569,035,980,800,000,000,000 > 2^{142}.
\]
Finding the correct string would take the adversary about
\[
  9,976,338,090,389,847,753,239,424 > 10^{24}
\]
years, or about
\[
  723,604,706,635,950 > 10^{14}
\]
ages of the Universe. Here we calculate the time it would take to find the correct entry with at least $50\%$ confidence, that is, the time to traverse half of the space of possible values.

\subsection{Attacks with a Known Pseudo-hash}

Having examined the \texttt{pshash} algorithm further, an attacker might try to brute-force the choice-shuffle key pair instead of the final pseudo-hash. The number of all relevant key pairs for our configuration is
\begin{align*}
  \#^{(k_1,k_2)} (\conf) =
    97,&667,663,944,563,885,279,694,955,400,689,334,\\
    &503,676,436,493,107,200,000,000,000,000,000 > 2^{225}.
\end{align*}

There is no possibility of traversing this number of values.

Now let us assume that one of the passwords generated with $\conf$ and $(k_1, k_2)$ has been compromised, for example due to a security leak on a website it was used to log into. Denote this leaked password by $h$. The attacker knows that there are exactly $\#^\cap (\conf)$ different key pairs that generate the pseudo-hash $h$. They can generate any number of these key pairs at leisure (by choosing the intermediate layer $\alpha$ between $\mc$ and $\s$). However, even if a key pair $(k'_1, k'_2)$ generates $h$, it need not generate any other pseudo-hash that was generated by the original key pair $(k_1,k_2)$, and the pseudo-hash $h$ gives no preference to any of these pairs. Therefore, the attacker still needs to identify the original key pair among the potential ones, of which there is
\[
  \#^\cap (\conf) = 15,511,210,043,330,985,984,000,000 > 2^{83}.
\]
Traversing half of this number of key pairs would take about
\[
  24,576,029 > 10^7
\]
years. It is, of course, almost infinitely better than brute-forcing the final pseudo-hash (it won't even take a single age of the Universe), but it is still pretty much impossible. However, if this is an issue, one can always use a password with, say, $30$ symbols instead of $25$, and its security properties will be considerably stronger.

\subsection{Multiple Known Pseudo-hashes}

Now, suppose that multiple pseudo-hashes $h_1, h_2, ..., h_n$ have been made available to the adversary, all produced with the same choice-shuffle key pair $(k_1, k_2)$ and different public keys $p_1, p_2, ..., p_n$ which are also known. Denote the number $\#^\mc (\conf)$ by $N$. Essentially, the adversary needs to solve for $(k_1, k_2)$ the following system of equations:
\begin{align*}
  h_1 &= \h(\conf, \li^N (k_1 + p_1), k_2),\\
  h_2 &= \h(\conf, \li^N (k_1 + p_2), k_2),\\
  &\vdots\\
  h_n &= \h(\conf, \li^N (k_1 + p_n), k_2).
\end{align*}

Due to the argument shift function $T$, the pseudo-hash function is highly non-linear and cannot be described as an algebraic transformation of its inputs. Hence there is no way (as to our knowledge) to narrow down the space of possible solutions of the above system without simply traversing $\#^\cap (\conf)$ different key pairs and checking whether they produce all the given pseudo-hashes.

In other words, we have seen that \texttt{pshash} is resistant to various brute-force attacks and dictionary attacks.

\subsection{Supply Chain Attacks}

Being a standalone program, \texttt{pshash} is not susceptible to supply chain attacks. However, this also means \texttt{pshash} does not protect from phishing and keyloggers, being completely unaware of them. Hence, \texttt{pshash} should be used with care, as it is only responsible for producing a password, and not for how it is used afterwards.

\section{The Implementation} \label{impl}

For the primary implementation of the $\h(-, -, -)$ function, we have chosen the Haskell programming language. This choice is natural because the \texttt{pshash} algorithm does not involve any mutation and hence fits perfectly into the functional paradigm. Additionally, implementing it in a statically typed functional language ensures a degree of reliability due to a powerful type system and the inability to mutate values. Haskell also has a mature package ecosystem and first-class support for arbitrary-precision integers, which is necessary for computing the spreads of the functions involved in our algorithm.

The primary implementation is a CLI program running in the console. It was designed without any GUI in order to make it more lightweight and portable, as well as faster. It is fully open-source, with source code available on GitHub \cite{pshash-src}, together with installation instructions.

The general invocation of \texttt{pshash} is \verb|$ pshash PUBLIC CHOICE SHUFFLE|, providing the public key and the choice-shuffle private key-pair. To avoid passing secrets directly as command-line arguments, the user may omit any of the three arguments and provide them via \texttt{stdin}. In addition, the program has many flags and options, all of which can be viewed by invoking \verb|$ pshash --help|. We will expand on some of the most important features below.

\subsection{Simplified Key Input and Generation}

One of the biggest disadvantages of \texttt{pshash} is the size of the private keys. For the source configuration given in Section \ref{security}, the maximum relevant choice key is on the order of $2^{142}$ and the maximum shuffle key on the order of $2^{83}$. Such long numbers are possible to remember using mnemonics, but they still take a lot of effort to commit to memory, and the cost of forgetting even a single digit is the permanent loss of all passwords derived from this key-pair. Additionally, even coming up with such big numbers is hard for a human to do. One would inevitably think of numbers relevant in their life, which makes them vulnerable to social analysis attacks.

These problems are solved in the implementation of \texttt{pshash} as follows:

\begin{itemize}
  \item The program can generate random keys via invoking \verb|$ pshash --gen-keys|. The keys are automatically selected from the range corresponding to the source configuration in use (see Subsection \ref{conf} for more information on how they are specified). This ensures that the generated keys are uniformly distributed in the relevant range, and allows the passwords generated by these keys to enjoy the security properties discussed in Section \ref{security}.

  \item The program supports alternative input methods for the keys. For example, it can evaluate arithmetic expressions involving addition, multiplication, and exponentiation. Instead of \texttt{52046849220153179918678225216} one may type \texttt{8234 * 91234 \^{} 5} which is much easier to remember. Of course, if this input method becomes mainstream, a brute-force attack on such passwords will be much easier, since it will be enough to check all numbers of the form $a + b$, $a * b$, $a ^ b$ and some basic combinations of these expressions, where $a,b < 100,000$. Hence the arithmetic input method is not preferred.\\
    As a safer alternative, the \texttt{pshash} implementation offers an ``mnemonic incantation system''. By selecting the 100 most used English 2-letter syllables, we associate each 2-digit number with a syllable. For example, \texttt{00} corresponds to \texttt{or}, \texttt{37} corresponds to \texttt{mi}, and \texttt{99} corresponds to \texttt{je}. We can then apply this map to whole numbers, so \texttt{993700} becomes \texttt{jemior}, which sounds like an English word and is much easier to remember. Given the source configuration described in Section \ref{security}, the average choice key will have about 7 3-syllable words in its mnemonic incantation, while the average shuffle key will have about 4 words. An example would be
    \begin{align*}
      5925758263543757867984307717119455838590518 \ &\longleftrightarrow \ \mathtt{usjusu\ sodilo\ hiwewa\ quzihi\ agfefe\ riposo\ tobius\ li}\\
      14597701819718601692712560 \ &\longleftrightarrow \ \mathtt{rebifu\ unpuja\ litule\ jufela\ tu}
    \end{align*}
    Remembering these incantations still requires effort, of course, but it is feasible, and the nature of \texttt{pshash} is such that the security properties of passwords rely directly on the amount of entropy in the keys.\\
    To generate an incantation, the user may invoke \verb|$ pshash --gen-spell|. They will be prompted for the numeric key (which can be typed as an arithmetic expression), after which the incantation will be printed as output. The \verb|$ pshash --gen-keys| command will also automatically print corresponding incantations.
\end{itemize}

\subsection{Error Messages}

The \texttt{pshash} implementation supports a state-of-the-art error message system. Whenever the algorithm fails at any step, a helpful error message with a stack trace will be printed. For example, \verb|$ pshash asd asd asd| will produce

\begin{verbatim}
ERROR:
|_Double trace:
  |_Trace while computing hash, getting the *choice* key:
  | |_Both numeric and mnemonic read methods failed:
  |   |_FAILED TO READ "*asd*" AS *integer*.
  |   |_UNKNOWN MNEMONIC SYLLABLE: "*as*".
  |_Trace while computing hash, getting the *shuffle* key:
    |_Both numeric and mnemonic read methods failed:
      |_FAILED TO READ "*asd*" AS *integer*.
      |_UNKNOWN MNEMONIC SYLLABLE: "*as*".
\end{verbatim}

On UNIX-based systems, the error output will also be colored to highlight the relevant parts. Such a detailed error output is achieved via the concept of monadic data structures prevalent in functional programming languages. In essence, most functions in the \texttt{pshash} implementation source code return may return either a value or an error object which keeps a trace of error messages. The error system makes \texttt{pshash} reliable in the sense that, if the program runs without errors, the user can be sure that all inputs were interpreted correctly and the resulting pseudo-hash can be safely used.

\subsection{Key Retrieval}

As mentioned before, if the final pseudo-hash $h$ and, say, the choice private key $k_1$ are given, one can solve the equation $h = \h(\conf, k_1, x)$ to find the shuffle key $k_2$ (modulo the spread of $\s$, of course). Similarly, the choice key (modulo the spread of $\mc$) can be retrieved from the shuffle key and the final pseudo-hash.

Since this can be done, there is no reason why this functionality should not be included in the implementation of \texttt{pshash}. By invoking \verb|$ pshash -q KEYWORD|, where \verb|KEYWORD| is either \verb|public|, \verb|choice|, or \verb|shuffle|, the user will be prompted for the two remaining keys and the final pseudo-hash, after which the desired key will be printed to the console.

This functionality is useful if the user forgets one key but not the other, and has access to one of the passwords produced with that key-pair. 

Moreover, the \verb|--list| flag allows to print the first $N$ choice-shuffle key-pairs that produce a given pseudo-hash with a given public key.

\subsection{Specifying the Source Configuration} \label{conf}

The source configuration $\conf$ is not given to \texttt{pshash} as a direct argument, but optionally specified with one of the \verb|-k|, \verb|-n|, and \verb|-c| flags. See \verb|$ pshash --help| for more details.

Since different websites have different password requirements, the implementation of \texttt{pshash} provides many built-in source configuration templates. The default is the one given in Section \ref{security}, and it will be used if no other is specified. The default configuration produces passwords that are accepted by most websites, but for rare cases there are purely alphanumeric templates of different sizes, as well as pin code templates.

Additionally, the user can write a \emph{configuration file} which specifies source configurations for different public keys. This file can then be read from a standard location if the \verb|--impure| flag is passed to \texttt{pshash}. Note that the default behavior of \texttt{pshash} is to ignore all configuration files, to ensure that the program functions deterministically and gives the same outputs on any machine. The \verb|-f PATH| can also be passed, which automatically implies \verb|--impure| and will cause \texttt{pshash} to read the configuration file from \verb|PATH|. For details on the configuration file format, see \verb|$ pshash --help|.

\subsection{Replacing Passwords}

If one of the passwords produced by \texttt{pshash} is compromised, the safest option is to create a new random key-pair and change all passwords. However, this is obviously inconvenient. For this reason, the \texttt{pshash} implementation provides a ``public key patch'' mechanism. Patches can be specified with the \verb|-p| flag, as in \verb|$ pshash PUBLIC -p N|. This will shift all characters in \verb|PUBLIC| by \verb|N| modulo $128$, and then use the ``patched'' public key as usual.

We readily see that \verb|$ pshash PUBLIC -p 0| is equivalent to \verb|$ pshash PUBLIC|, and that different patches produce different final pseudo-hashes, as long as \verb|N| is between $0$ and $128$.

This way, a user who needs a new password for, say, \verb|spotify|, can invoke \verb|$ pshash spotify -p 1| instead of\\ \verb|$ pshash spotify|. In order not to keep all patch values in their head, the user may also save them in the configuration file.

\subsection{File Encryption}

\subsection{Other implementations}

The \texttt{pshash} algorithm is implemented in its rudimentary form in other languages and deployed on other platforms:

\begin{itemize}
  \item \textbf{C} for the in-development desktop app, source at \url{https://github.com/thornoar/pshash-gui};
  \item \textbf{JavaScript} for the web interface \cite{pshash};
  \item \textbf{Kotlin} for the Android application, source at \url{https://github.com/thornoar/pshash-app}, with download links hosted at \url{https://thornoar.github.io/pshash-web/get/}.
\end{itemize}

For more information, see the respective GitHub repositories.

\bibliographystyle{abbrv}
\bibliography{main}

\end{document}
